{"meta":{"title":"花森煜米地","subtitle":"说学逗唱，混摄绘","description":"不定期分享总结个人遇到的问题、经验，欢迎一起交流学习。","author":"花森煜米","url":"https://jecyu.github.io/blog"},"pages":[{"title":"","date":"2018-09-26T15:47:03.056Z","updated":"2018-09-26T15:47:03.056Z","comments":true,"path":"404.html","permalink":"https://jecyu.github.io/blog/404.html","excerpt":"","text":""},{"title":"categories","date":"2018-05-02T15:18:14.000Z","updated":"2018-09-26T15:47:03.057Z","comments":true,"path":"categories/index.html","permalink":"https://jecyu.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-05-02T15:17:21.000Z","updated":"2018-09-26T15:47:03.058Z","comments":true,"path":"tags/index.html","permalink":"https://jecyu.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"知乎日报项目","slug":"2018-09-26-daily","date":"2018-09-25T16:00:00.000Z","updated":"2018-09-28T09:22:08.819Z","comments":true,"path":"2018/09/26/2018-09-26-daily/","link":"","permalink":"https://jecyu.github.io/blog/2018/09/26/2018-09-26-daily/","excerpt":"导语本项目根据《vue.js 实战》上完成的比较小型的单页面应用，没有使用 vue-router 和 vuex，作为一个 vue 新手的练习项目挺不错的，在这个过程中学习了： Vue 的单文件组件用法 Vue 的基本指令、自定义指令 数据的获取、整理、可视化（跨域处理） prop、事件、子组件索引（实践了组件之前的通信） ES6 模块（结合 《深入理解 ES6》）","text":"导语本项目根据《vue.js 实战》上完成的比较小型的单页面应用，没有使用 vue-router 和 vuex，作为一个 vue 新手的练习项目挺不错的，在这个过程中学习了： Vue 的单文件组件用法 Vue 的基本指令、自定义指令 数据的获取、整理、可视化（跨域处理） prop、事件、子组件索引（实践了组件之前的通信） ES6 模块（结合 《深入理解 ES6》） 一、需求分析左侧是菜单，分为“每日推荐”和“主题日报”两个类型，中间是文章列表，右侧是文章正 文和评论。其中每日推荐按日期排列，比如图中显示为 5 月 2 日的推荐文章，中间栏滚动至底部时，自动加载前 一 天的推荐内容。 主题日报有“日常心理学”等 10 多个子分类，分类列表默认是收起的，点击“主题日报”菜单时切换展开和收起的状态。点击某个子分类后，中间栏切换为该类目下的文章列表，不再按时间 排列。点击文章列表中的某一项，在右侧渲染对应文章的内容和评论。 二、数据处理本项目中使用到文章和图片，知乎日报的接口地址前缀为 http://news-at.zhihu.com/api/4/，图片地址前缀为https://pic1.zhimg.com，由于两者都开启了跨域限制，无法在前端直接调用，需要代理转发。 请求数据使用基于 Node.js 的 request 库来做代理，代理的核心是在返回的头部( response header)中添加一项 Access-Con 问 I-Allow-Origin 为“*”，也就是允许所有的域访问。 文字数据服务： // 创建一个 API 代理服务 const apiServer = http.createServer((req, res) =&gt; { const url = &quot;http://news-at.zhihu.com/api/4&quot; + req.url; // const url = &quot;https://cn.bing.com/?mkt=zh-CN&quot;; const options = { url: url }; function callback(error, response, body) { if (!error &amp;&amp; response.statusCode === 200) { // 设置编码类型，否则中文会显示为乱码 res.setHeader(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;); // 设置所有域允许跨域 res.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); res.end(body); } } request.get(options, callback); }); apiServer.listen(port, hostname, () =&gt; { console.log(`接口代理运行在 http://${hostname}:${port}/`); }); // 使用封装好的 axios 进行请求 getThemes() { // axios 发起 get 请求 $.ajax.get(&quot;themes&quot;).then(res =&gt; { this.themes = res.others; console.log(this.themes); }); } 图片服务： // 创建一个图片代理服务 const imgServer = http.createServer((req, res) =&gt; { const url = req.url.split(&quot;/img/&quot;)[1]; // const url = &quot;https://pic4.zhimg.com&quot; + req.url.split(&quot;/img/&quot;)[1]; console.log(url); const options = { url: url, encoding: null }; function callback(error, response, body) { if (!error &amp;&amp; response.statusCode === 200) { const contentType = response.headers[&quot;content-type&quot;]; res.setHeader(&quot;Content-Type&quot;, contentType); res.setHeader(&quot;Access-Control-Allow-origin&quot;, &quot;*&quot;); res.end(body); // console.log(body); } } request.get(options, callback); }); imgServer.listen(imgPort, hostname, () =&gt; { console.log(`图片代理运行在 http://${hostname}:${imgPort}/`); }); 注意：对于图片的请求，组件编译后的 HTML 为这样就可以被 node 代理了 组件通信本项目比较简单，因此组件之间的数据传递，使用 props 属性进行传递。 三、按需加载知乎日报属于比较小型的单页面应用，所需的组件体积比较小，对于一些大型项目时组件体积比较，且需要引入如 echart、iView、loadsh 等体积比较大的库时，可以通过按需加载大大提升项目初始化的构建速度。 按需加载组件（或异步组件）实现组件的按需加载, 在一些单个组件文件较大的时候, 采用按需加载能够减少 `build.js 的体积, 优化加载速度(如果组件的体积较小, 那么采用按需加载会增加额外的 http 请求, 反倒增加了加载时间) 对于 vue-cli 来说，默认情况下，一个 Vue CLI 应用会为所有作为 async chunk 生成的 JavaScript 文件 (通过动态 import() 按需 code splitting 的产物) 自动生成 prefetch 提示。 Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染 // index.vue // 按需加载（用于单个组件文件较大时） const Item = resolve =&gt; require([&quot;./Item&quot;], resolve); const dailyArticle = resolve =&gt; require([&quot;./DailyArticle&quot;], resolve); export default { name: &quot;index&quot;, components: { Item: Item, dailyArticle: dailyArticle // Item, // dailyArticle }, ... } 异步组件： Vue.component(&apos;async-example&apos;, function (resolve, reject) { setTimeout(function () { // 向 `resolve` 回调传递组件定义 resolve({ template: &apos;&lt;div&gt;I am async!&lt;/div&gt;&apos; }) }, 1000) }) Vue.component(&apos;async-webpack-example&apos;, function (resolve) { // 这个特殊的 `require` 语法将会告诉 webpack // 自动将你的构建代码切割成多个包，这些包 // 会通过 Ajax 请求加载 require([&apos;./my-async-component&apos;], resolve) }) 按需加载第三方库如果日后需要扩展引入可视化功能，对于日报的产出文章分类或阅读量可视化显示，则百度 echarts 图表是一个非常适合的选择。如果是完整的引入 Echarts，会额外的引入其他无用的配置文件，造成应用文件体积过大，资源加载耗时过长，影响用户体验。（其他库如 iview、loadsh 等同理） 原理： 专门设置一个 echarts 配置文件 在需要的组件内加载 echarts 配置文件，绘制图表补充：另外可以引入插件 babel-plugin-equire, 配合实现 Echarts 更方便按需引入 详情看：百度 Echarts 图表在 Vue 项目的完整引入以及按需加载 总结 针对跨域的处理，也可以使用 Fiddler 协助开发，在部署服务器时，则可以使用 ngnix 代理转发请求） 自定义指令与计算属性区别 数据来源不同，自定义指令可以适用于列表 v-for 这样的临时值 comment，直接使用并设置绑定的 dom &lt;div class=&quot;daily-comment&quot; v-for=&quot;comment in comments&quot; :key=&quot;comment.id&quot;&gt; &lt;div class=&quot;daily-comment-avatar&quot;&gt; &lt;img :src=&quot;comment.avatar&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;daily-comment-content&quot;&gt; &lt;div class=&quot;daily-comment-name&quot;&gt;{{ comment.author }}&lt;/div&gt; &lt;div class=&quot;daily-comment-time&quot;&gt;{{ comment.time }}&lt;/div&gt; &lt;div class=&quot;daily-comment-text&quot;&gt;{{ comment.content }}&lt;/div&gt; &lt;/div&gt; 本项目 github 地址: https://github.com/Jecyu/daily (完) 参考资料 Webpack 的 Code Splitting 实现按需加载 百度 Echarts 图表在 Vue 项目的完整引入以及按需加载 前端跨域方法论 Vue 异步组件","categories":[{"name":"js相关","slug":"js相关","permalink":"https://jecyu.github.io/blog/categories/js相关/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://jecyu.github.io/blog/tags/vue/"}]},{"title":"网站线上部署","slug":"2018-04-30-Website-Deployment","date":"2018-04-29T16:00:00.000Z","updated":"2018-09-28T06:20:22.479Z","comments":true,"path":"2018/04/30/2018-04-30-Website-Deployment/","link":"","permalink":"https://jecyu.github.io/blog/2018/04/30/2018-04-30-Website-Deployment/","excerpt":"本文要实现一个前后端分离的网站项目的线上部署，网站预览地址，源码地址，在部署的过程踩了不少坑，现在总结实现步骤如下，文章涉及到 local$ 和 remote$ 等标识符为区分本地环境和远程服务器所用，后端配置 Node.js + Mongodb + Nginx。","text":"本文要实现一个前后端分离的网站项目的线上部署，网站预览地址，源码地址，在部署的过程踩了不少坑，现在总结实现步骤如下，文章涉及到 local$ 和 remote$ 等标识符为区分本地环境和远程服务器所用，后端配置 Node.js + Mongodb + Nginx。 一、 连接远程服务器, 配置 Node.js 环境连接服务器在这里花森煜米的本地系统是 win10。 配合使用命令行工具 cmder，给予你在 window 下的 Linux 环境。然后通过 ssh 进行连接远程服务器 CentOS 7（这里是你自己的服务器。) SSH Client 的基本用法如下： ssh user@remote -p port // 执行该行命令后，会提示输入你的用户密码 user@remote&apos;s password: 成功连接服务器后，这里是 linux 目录结构。搞清楚每个目录的作用，把你自定义的文件放到最合适的地方。 目录 描述 / 第一层次结构 的根、 整个文件系统层次结构的根目录。 /bin 计算机的可执行二进制文件，如 cat，ls，cp。 /boot 引导程序文件，例如： kernel、initrd。 /dev 必要设备，如 /dev/null。 /etc 特定主机，系统范围内的配置文件。 /home 当前用户的主目录，包含保存的文件，个人设置等。 /lib /bin 和 /sbin 中的二进制文件依赖的库文件。 /media 可移除媒体的挂载点（如 CD-ROMS）。 /mnt 临时挂载的文件系统。 /opt 可选的应用程序软件包。 /proc 虚拟文件系统，将内核与进程状态归档为文本文件。 /root 超级用户的主目录。 /run 自最后一个启动以来运行中的系统的信息。例如：当前登录的用户和守护进程。 /sbin 必要的系统二进制文件，如 fsck，init，route。 /srv 站点的具体数据，由系统提供。例如 web 服务器的数据和脚本。 /sys 包含有关设备、驱动程序和一些内核功能的信息。 /tmp 临时文件，通常在系统重启时不会被保留。 /usr 用于存储只读的用户数据第二层次结构，包含绝大多数的（多）用户工具和应用。 /var 变量文件——在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。 配置 Node.js使用 Node.js 不仅仅是实现后端应用，还实现了整个 HTTP 服务器，服务器可以监听客户端的请求，类似 Apache、Nginx 等 HTTP 服务器。首先把 Node.js 安装到 /usr/local 目录下，然后分别为 node 和 npm 命令建立软连接，以便在任何地方都可以调用它们。 # 这里安装的是当前 node.js 的稳定版本 wget https://npm.taobao.org/mirrors/node/v8.11.1-linux-x64.tar.xz # 两次解压 xz -d node-v8.11.1-linux-x64.xz tar xzvf node-v8.11.1-linxu-x64.tar # 建立软连接 ln -s /usr/local/node-v8.11.1-linxu-x64/bin/node /usr/local/bin/node ln -s /usr/local/node-v8.11.1-linxu-x64/bin/npm /usr/local/bin/npm 二、 配置 Mongodb 数据库环境安装 Mongodb 与 Node.js 步骤差不多，需要额外设置的是新建一个 mongodb 文件夹，用于存在数据库的数据 data、 配置 etc 和 logs 日志文件以及 Mongodb 程序文件。 安装 Mongodb 数据库# 安装 Mongodb 当前的稳定版本 curl http://downloads.mongodb.org/linux/mongodb-linux-x86_64-3.6.4.tgz &gt; mongo.tgz # 进行解压 tar xzvf mongo.tgz # 当前 mongodb 下的文件 data etc logs mongodb-linxu-x86_64-3.6.4 现在在 etc 文件下，新建配置文件 mongo.conf，配置如下： dbpath=/mongodb/data logpath=/mongodb/logs/mongo.log logappend=true journal=true quiet=true port=27017 保持数据库一直运行保持程序在后台运行，可以通过系统服务 systemctl start mongod -f /mongodb/etc/mongo.conf 来实现，也可以通过把程序保存为守护(daemon)进程 mongod --fork /mongodb/etc/mongo.conf。数据库开启后，通过初始化设置后（可以看这里），可以在本地使用客户端如 NoSQLBooster for MongoDB 来连接远程服务器的数据库,注意的是如果要使用客户端来连接，需要在 /etc/mongo.conf 更改 bind_ip = 0.0.0.0, 默认是 bind_ip = 127.0.0.1 只允许在服务器主机进行数据库连接。 三、 上传网站项目文件至服务器一般上传文件到服务器，可以通过 scp 协议上传，也可以通过支持 SFTP 协议的客户端图形化工具如 FileZilla 上传。 通过 scp 协议上传# 把本地的文件上传到服务器，如果上传的是文件夹，则在路径前加 `-r`。 scp -P port (-r) /path/to/local/file user@remote$_address:/path/to/remote/file 通过 SFTP 协议上传使用 SFTP 可以通过用户名和密码连接服务器，也可以使用公钥无密码连接。 对于前后端分离的项目，前端项目文件建议放在 /var/www/myapp.com 下，而后端项目文件花森煜米放置在根目录 /workspace/myapp-backend 下，然后可以使用 PM2 工具后台运行 Node.js 服务器。以上均是手动部署，一个项目会经过不断的版本迭代更新，为避免人工部署的出错，我们一般编写自动化部署脚本，从 github 上 pull 最新的项目文件，完成自动化部署，可参见 https://github.com/visionmedia/deploy。 四、 使用 Nginx 配置域名和代理请求使用 Nginx 可以通过二级域名或二级目录（通过 node server 子目录来访问前端项目）来访问放置在 /var/www/myapp.com 的前端项目文件，本项目采用的是二级域名方法来访问（需要注意的是，二级域名要提前在服务器进行域名解析，否则访问不到。），因此会涉及到前后端交互跨域的问题，通过设置 Nginx 来代理转发请求。 安装 Nginx 服务器首先添加 Nginx 存储库(资料库)，关于包管理器可以看这篇文章。创建一个名为 /etc/yum.repos.d/nginx.repo，然后粘贴下面的配置 [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 然后通过以下命令进行安装 yum install nginx 命令语法： nginx -s signal stop— 快速关机 quit— 优雅的关机 reload— 重新加载配置文件 reopen— 重新打开日志 log 文件 域名配置和转发请求在 /etc/nginx 中，nginx.conf 为主配置文件。另外我们需要新建两个文件夹放置自定义的设置 sites-available 用于保存所有的服务器配置文件。 sites-enable 保存我们想要发布的服务器配置文件的软链接。 首先在打开 nginx.conf，在结尾处添加以下代码，确保在 sites-enable 中查找 server block {}： include /etc/nginx/sites-enabled/*.conf; server_names_hash_bucket_size 64; 在 sites-available 中，创建 myapp.com.conf，设置以下： server { listen 80; # 二级域名配置 server_name *.linjiyu.com; # 访问的文件根目录 root /var/www/linjiyu.com/ebio; index index.html index.htm; #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / { # pass-on visitor real-IP to backend proxy_set_header X-Real-IP $remote_addr; # proxy_pass http://127.0.0.1:8080/; } # 转发请求 location /users/ { proxy_set_header Host $host; proxy_pass http://127.0.0.1:3000/users/; } } # ... 这里可以继续配置第二个域名 # server { # } 五、 参考资料 Initial Server Setup with CentOS 7 Secure Shell SSH 基本用法 Filesystem Hierarchy Standard How to Install and Configure MongoDB on CentOS 7 How To Set Up Nginx Server Blocks on CentOS 7 （完）","categories":[{"name":"后端相关","slug":"后端相关","permalink":"https://jecyu.github.io/blog/categories/后端相关/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://jecyu.github.io/blog/tags/Linux/"},{"name":"Node.js","slug":"Node-js","permalink":"https://jecyu.github.io/blog/tags/Node-js/"},{"name":"Mongodb","slug":"Mongodb","permalink":"https://jecyu.github.io/blog/tags/Mongodb/"},{"name":"Nginx","slug":"Nginx","permalink":"https://jecyu.github.io/blog/tags/Nginx/"}]},{"title":"前端路由窥探","slug":"2018-01-19-FE-router","date":"2018-01-19T16:00:00.000Z","updated":"2018-09-27T07:23:59.529Z","comments":true,"path":"2018/01/20/2018-01-19-FE-router/","link":"","permalink":"https://jecyu.github.io/blog/2018/01/20/2018-01-19-FE-router/","excerpt":"如图，用户点击链接的过程，就像是路飞发出一个请求 URL，要去女帝的国家，至于如何到达，路飞不用管，交给娜美处理就好（这里娜美制定各种航线，到达目的地）。在浏览一个网站时，我们可以通过当前点击各种超链接，从而浏览不同的页面内容，在这其中发生的过程是： 点击一个链接，改变当前网站的 URL ，通过浏览器发送请求； 服务端接收请求，处理解析 URL 路径； 根据服务器的路由配置，返回新的数据（图片、json 数据）、页面等； 浏览器来根据数据包的 Content-Type 来决定如何解析数据。 结论：路由是请求连接到某些代码的机制，通过检测当前页面的 URL 地址，与服务端进行交互，返回对应的页面内容。我们常听说前端路由与后端路由，","text":"如图，用户点击链接的过程，就像是路飞发出一个请求 URL，要去女帝的国家，至于如何到达，路飞不用管，交给娜美处理就好（这里娜美制定各种航线，到达目的地）。在浏览一个网站时，我们可以通过当前点击各种超链接，从而浏览不同的页面内容，在这其中发生的过程是： 点击一个链接，改变当前网站的 URL ，通过浏览器发送请求； 服务端接收请求，处理解析 URL 路径； 根据服务器的路由配置，返回新的数据（图片、json 数据）、页面等； 浏览器来根据数据包的 Content-Type 来决定如何解析数据。 结论：路由是请求连接到某些代码的机制，通过检测当前页面的 URL 地址，与服务端进行交互，返回对应的页面内容。我们常听说前端路由与后端路由， 一、服务端路由 &amp;&amp; 客户端（前端）路由服务端路由 当浏览一个页面的时候，点击链接时会从服务器请求一个新的页面，以此带来的时对整个页面进行刷新，这就是服务端路由。由于存在许久，这种方法对搜索爬虫比较友好，而且只会请求我们需要的数据。缺点是，每次都是进行整个页面的刷新，尽管网页的头部和尾部都是相同的。其次，当网页内容非常大或我们不在处在服务区边缘的时候，就需要等比较久。现在网速已经达到 100M/s，这个缺点往往可以忽略了。 前端路由 前端路由衍生于后端，都是需要跟服务端交互的，区别是一开始就把整个网站需要的内容加载完毕，然后通过在 JavaScript 路由处理，检测 URL 状态变化（change State），不用刷新页面就可以进行页面内容（view）的更换了。 我们知道使用 ajax 可以进行异步刷新，而使用前端路由，我们还可以做到页面跳转也不用刷新，配合它们就可以妥妥造飞机了。 二、前端路由实现原理前端路由实现有两种方式，一种是 hash 形式，另外一种是利用 history API 来处理。实现过程： 检测状态改变 调用回调函数 重新渲染视图 以 hash 形式，当 url 的 hash 发生改变时，触发 haschange 事件注册的回调，进行页面 DOM 的更换。 function Router() { this.routes = {}; this.currentUrl = &quot;&quot;; } /** * 1.存储路由更新时的回调到回调数组 routes 中，回调函数将负责对页面的更新 * @param {*} path * @param {*} callback */ Router.prototype.route = function(path, callback) { this.routes[path] = callback || function() {}; }; /** * 2.refresh 执行当前 url 对应的回调函数，更新页面 */ Router.prototype.refresh = function() { this.currentUrl = location.hash.slice(1) || &quot;/&quot;; this.routes[this.currentUrl](); }; /** * 3.init 监听浏览器 url hash 更新页面 */ Router.prototype.init = function() { window.addEventListener(&quot;load&quot;, this.refresh.bind(this), false); window.addEventListener(&quot;hashchange&quot;, this.refresh.bind(this), false); }; 应用例子： 三、实现一个需求： tabs 与下拉菜单的联动 实现的效果： 用户点击下拉菜单，页面的 banner 进行更换，页面 tabs 进行相应的切换。有两种方法实现： 通过调用后端接口，进行局部页面刷新。 原始方法，静态页面，所有页面内容放在同一个页面下，使用 JavaScript 原始 router 实现。利用我们刚刚学到的知识，可以解决这个问题了。 前端路由： HTML 结构： &lt;li class=&quot;dropdown&quot;&gt; &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt;合作与生态 &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/a&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt; &lt;a href=&quot;cooperation-ecology.html#/card_cooperation&quot; data-targetTab=&quot;card_cooperation&quot;&gt;发卡合作&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;cooperation-ecology.html#/industry_cooperation&quot; data-targetTab=&quot;industry_cooperation&quot;&gt;行业合作&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;cooperation-ecology.html#/pay_for_access&quot; data-targetTab=&quot;pay_for_access&quot;&gt;支付接入&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; 第一步：定义回调函数，这里是更改页面的 tab 和 banner 内容 /** * 更换 tab 内容 * @param {*} tabNav * @param {*} tabConent * @param {string} bannerUrl 图片地址 */ function changeTab(tabNav, tabConentID, bannerUrl) { // 遍历 a 链接，添加 active tabNav.each(function(index) { if ($(this).attr(&quot;data-targetTab&quot;) === tabConentID) { $(this) .parent() .addClass(&quot;active&quot;) .siblings() .removeClass(&quot;active&quot;); } }); // 显示对应的 tab-content $(&quot;#&quot; + tabConentID) .show() .siblings() .hide(); // 显示对应的 banner // 找到 banner var $banner = $(&quot;.section-banner .banner&quot;); var $banner_img = $banner.find(&quot;img&quot;); // 图片地址 $banner_img.attr(&quot;src&quot;, bannerUrl); } 第二步：定义路由规则，绑定路由函数 // 初始化路由 window.Router = new Router(); window.Router.init(); // 找到 tabs link var $tabs_nav = $(&quot;.tabs-nav&quot;); var $tabs_item_link = $tabs_nav.find(&quot;.nav-item a&quot;); // 操作tab var tab_1 = &quot;card_cooperation&quot;; var tab_2 = &quot;industry_cooperation&quot;; var tab_3 = &quot;pay_for_access&quot;; var tab_1_bannerUrl = &quot;../images/product/product_banner-1.png&quot;; var tab_2_bannerUrl = &quot;../images/product/product_banner-2.png&quot;; var tab_3_bannerUrl = &quot;../images/product/product_banner-1.png&quot;; Router.route(&quot;/&quot; + tab_1, function() { changeTab($tabs_item_link, tab_1, tab_1_bannerUrl); }); Router.route(&quot;/&quot; + tab_2, function() { changeTab($tabs_item_link, tab_2, tab_2_bannerUrl); }); Router.route(&quot;/&quot; + tab_3, function() { changeTab($tabs_item_link, tab_3, tab_3_bannerUrl); }); 这样只需要指明当前链接的 hash 属性指向，绑定自定义的回调函数，就可以实现 tabs 与下拉菜单的联动。 小结：利用路由可以实现页面的跳转不刷新，只需要监听当前 hash 的变化，就可以实现 DOM 视图的更新了。 参考资料 Server-side vs Client-side Routing 前端路由实现与 react-router 源码分析 前端路由的前生今世及实现原理 前端路由的两种实现原理","categories":[{"name":"js相关","slug":"js相关","permalink":"https://jecyu.github.io/blog/categories/js相关/"}],"tags":[{"name":"路由，联动","slug":"路由，联动","permalink":"https://jecyu.github.io/blog/tags/路由，联动/"}]},{"title":"使用HTML5 localStorage实现本地存储","slug":"2017-12-10-Local-Storage-And-How-To-Use-It-On-Website","date":"2017-12-09T16:00:00.000Z","updated":"2018-09-27T07:24:29.963Z","comments":true,"path":"2017/12/10/2017-12-10-Local-Storage-And-How-To-Use-It-On-Website/","link":"","permalink":"https://jecyu.github.io/blog/2017/12/10/2017-12-10-Local-Storage-And-How-To-Use-It-On-Website/","excerpt":"在用户计算机上本地存储信息对于网站开发人与来说是一个强大的策略。在本文中，我们将可以学到了 localStorage 在计算机上存储信息是多么地容易，并解释了它的应用。","text":"在用户计算机上本地存储信息对于网站开发人与来说是一个强大的策略。在本文中，我们将可以学到了 localStorage 在计算机上存储信息是多么地容易，并解释了它的应用。 一、使用 LocalStorage 的目的：为了添加状态到 Web 应用中HTTP 协议作为网络的主要传输层的最大问题是无状态的，即服务器不知道用户上一次做了什么，这样意味着你使用浏览器访问一个网站如辛苦的填了一个表单，由于不可描述的原因，网站被关闭。然后你再次重新打开它时，空空如也，what！！？？？？这是因为你关闭桌面上的应用程序时并重新打开它，它会恢复到最新的状态，不会记录你所填的东西。 这就是为什么作为开发人员，有时候你需要将你的接口状态存储到某个地方。通常，这是在服务端完成的，通过检测用户名来知道要恢复到哪个状态。但是如果你不想强迫别人进行注册呢？（旁白：有时候我们只是蹭蹭不进去 😄） 这时候就需要 local storage 出场了，你可以在用户的计算机上保存一个钥匙 key，在用户重新访问时获取它来记录蹭过的痕迹。 二、使用 cookie 对我们来说足够好了吗？双十一零点零分，花森赶快打开某宝，不用输入帐号密码就登录了（其实是 Cookie 在起作用，记录了上次的登录信息）。真好！花森速速浏览了几个网页，买了一套 cosplay 女装。在结账时由于 http 的无状态性，服务器并不知道用户（花森）到底买了什么。经典做法是使用 cookie，服务器通过设置或读取 Cookies 中的信息，来维护用户（花森）跟服务器的会话状态。在花森选购一项商品时，服务器在向花森发送网页的同时还发送一段 Cookie，记录着 cosplay 女装的信息。当花森去访问另一个页面时，浏览器会把 Cookie 发送给服务器，于是服务器就知道花森之前买了什么啦。花森继续购买鞋子，这时候服务器只需要在那段 Cookie 中追加新的商品信息就行了。结账时，服务器读取发送来的 Cookie 就行了。 但是使用 Cookie 有几个缺陷： Cookie 会被附加到每个 HTTP 请求中，无形中增加了流量。 由于 HTTP 请求中的 Cookie 是明文传递的，所有存在安全性问题，一些有安全意识的人或公司会手动关闭 Cookie 设置。 Cookie 大小限制在 4KB 左右，无法应对比较复杂的存储需求。 为了解决本地存储问题，使用 Cookie 是相对过时的方案，如今我们可以通过 localStorage 来实现。 三、在支持 HTML5 的浏览器中开始 localStorage在现代浏览器中使用本地 localStorage 是相当容易的，你只需要在 JavaScript 脚本中修改 localStorage 对象，它是 key/value 形式，与传统的对象类似。可以通过setItem()和getItem()方法来访问存储和读取的功能。 localStorage.setItem(&apos;girlfriend&apos;, &apos;huasen&apos;); var hername = localStorage(&apos;girlfriend&apos;); // -&gt; &quot;huasen&quot; 要删除这个 key 项，你可以使用-你能猜到？——the removeItem() localStorage.removeItem(&apos;girlfriend); var hername = localStorage.getItem(&apos;girlfriend); // -&gt; null 很简单有木有？！如果你希望关闭浏览器就自动清除数据，那你可以使用 sessionStorage 来代替 localStorage，它们用法相同，只是生命周期不同。（localStorage 除非被清除，否则会永久保存） 四、 仅“字符串”问题localStorage 中有一个令人讨厌 😒 的缺点是只能在不同的键 key 中存储字符串，这意味着当你开开心心 new 出来一个对象，（终于有对象了。）却不能把它存储起来，(づ ╥﹏╥)づ。 var girl = {}; girl.name = &apos;huasen&apos;; girl.hobby = [&apos;singing&apos;, &apos;photography&apos;]; girl.sound = &apos;pleasant&apos;; console.log(girl); localStorage.setItem(&apos;girl&apos;, girl); console.log(localStorage.getItem(&apos;girl&apos;)); 在控制台中输出，可以看到这个数据是以[object Object]的形式存储的，而不是真实的对象信息。你可以通过使用原生JSON.stringfy()和JSON.parse()方法来解决这个问题 localStorage.setItem(&apos;girl&apos;, JSON.stringify(girl)); console.log(JSON.parse(localStorage.getItem(&apos;girl&apos;))); 译自：Local Storage And How To Use It On Websites (完) 进一步阅读 What is the difference between localStorage, sessionStorage, session and cookies? MDN Using the Web Storage API 维基百科 Cookie 详说 Cookie, LocalStorage 与 SessionStorage HTML5 indexedDB 前端本地存储数据库实例教程","categories":[{"name":"译文","slug":"译文","permalink":"https://jecyu.github.io/blog/categories/译文/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://jecyu.github.io/blog/tags/html5/"}]},{"title":"使用 github 快速构建个人博客","slug":"2018-04-30-Build-A-Personal-Blog-quickly-Using-Github","date":"2017-12-09T16:00:00.000Z","updated":"2018-09-27T07:22:09.344Z","comments":true,"path":"2017/12/10/2018-04-30-Build-A-Personal-Blog-quickly-Using-Github/","link":"","permalink":"https://jecyu.github.io/blog/2017/12/10/2018-04-30-Build-A-Personal-Blog-quickly-Using-Github/","excerpt":"通常，在我们做一个项目，难免会踩不少坑，把它们记录下来好处多多。可以方便日后遇到同一个问题时，能够快速回顾之前的解决思路，不用再从头摸索，毕竟时间就是金钱。除了使用博客园、CSDN 等外，我们还想构建自己的博客，它让我们有一个属于自己的家园。好啦，blablabla，下面开始实现：","text":"通常，在我们做一个项目，难免会踩不少坑，把它们记录下来好处多多。可以方便日后遇到同一个问题时，能够快速回顾之前的解决思路，不用再从头摸索，毕竟时间就是金钱。除了使用博客园、CSDN 等外，我们还想构建自己的博客，它让我们有一个属于自己的家园。好啦，blablabla，下面开始实现： 一、使用 Hexo 生成博客骨架配置好 github 环境首先在 github 上创建一个库来放置你的博客文件，在这里花森煜米创建了 blog 仓库，然后通过本地 git 获取远程仓库，创建 gh-pages 分支，并在远程仓库的设置中，选择 gh-pages branch 作为 Github Pages 的构建文件。 // 克隆远程仓库到本地，这里默认的是主分支 master branch，存储博客源文件 git clone [https://github.com/Jecyu/blog.git] // 新建分支 gh-pages，用于存储博客框架生成网站文件 git checkout gh-pages // 推送到远程仓库中 git push -u origin 二、使用 hexo 生成博客骨架在这里假设你已经在本地电脑上配置好 node.js 环境，因为 Hexo 是基于 node 的静态博客生成框架。 # 全局安装 hexo 构建文件，这里也可以选择 cnpm 国内淘宝源。 $ npm install -g hexo-cli # 执行初始化命令 $ hexo init blog # 进入 blog 文件夹 $ cd blog # 安装相关的依赖文件 $ npm install 初始化成功后，blog 的目录文件结构如下 . ├── _config.yml // 这里是网站的配置文件 ├── package.json ├── scaffolds ├── source | ├── _drafts // 草稿 | └── _posts // 发布的文章 └── themes // 网站的主题 现在打开 _config.yml 文件，配置好远程 github 地址和部署的设置 # URLurl: https://jecyu.github.io/blogroot: /blog/ # Deployment deploy: type: git repo: git@github.com:Jecyu/blog.git branch: gh-pages 通常我们在写完一篇博客后，先通过 hexo server 在本地预览博客网站，如果你对当前的主题不满意，你可以更改 _config.yml 里的主题文件，这里花森煜米使用的是 hexo-theme-next主题。 三、选择第三方服务存储静态图片、视频当你想要说明一个很抽象的概念时，图片一目了然。当你的博客网站图片很多的时候，我们就需要第三方云服务如七牛云，个人实名认证后，官方提供 10G 的免费流量，通常对于普通的个人博客网站已经足够了，后期若需要提升再购买付费服务即可。一切准备好了，使用 Markdown 或其他语言开始你的写作吧，然后把它存储到 posts 目录中，使用 hexo generate 生成静态文件后，通过 hexo deploy (这里的本地分支为 master 分支)后，一个在线的个人博客网站生成。 四、进一步阅读 hexo 官方文档 (完)","categories":[{"name":"web 综合","slug":"web-综合","permalink":"https://jecyu.github.io/blog/categories/web-综合/"}],"tags":[{"name":"github","slug":"github","permalink":"https://jecyu.github.io/blog/tags/github/"}]}]}